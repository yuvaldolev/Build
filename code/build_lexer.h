#if !defined(BUILD_LEXER_H)

/* TODO(yuval): Create Default Ast Types For These Keywords:
KEYWORD_TOKEN_TYPE(Void, "void")
KEYWORD_TOKEN_TYPE(Bool, "bool")
KEYWORD_TOKEN_TYPE(Char, "char")
KEYWORD_TOKEN_TYPE(Int, "int")
KEYWORD_TOKEN_TYPE(Float, "float")
KEYWORD_TOKEN_TYPE(Double, "double")
KEYWORD_TOKEN_TYPE(Long, "long")
KEYWORD_TOKEN_TYPE(Short, "short")
KEYWORD_TOKEN_TYPE(Unsigned, "unsigned")
*/

#define TOKEN_TYPES \
TOKEN_TYPE(UNKNOWN) \
TOKEN_TYPE(TERNARY) \
TOKEN_TYPE(OPEN_BRACKET) \
TOKEN_TYPE(CLOSE_BRACKET) \
TOKEN_TYPE(OPEN_PAREN) \
TOKEN_TYPE(CLOSE_PAREN) \
TOKEN_TYPE(OPEN_BRACE) \
TOKEN_TYPE(CLOSE_BRACE) \
TOKEN_TYPE(PERIOD) \
TOKEN_TYPE(TILDE) \
TOKEN_TYPE(SEMI) \
TOKEN_TYPE(COMMA) \
TOKEN_TYPE(AT) \
TOKEN_TYPE(AMP) \
TOKEN_TYPE(AMP_AMP) \
TOKEN_TYPE(AMP_EQUAL) \
TOKEN_TYPE(STAR) \
TOKEN_TYPE(STAR_EQUAL) \
TOKEN_TYPE(PLUS) \
TOKEN_TYPE(PLUS_PLUS) \
TOKEN_TYPE(PLUS_EQUAL) \
TOKEN_TYPE(MINUS) \
TOKEN_TYPE(MINUS_MINUS) \
TOKEN_TYPE(MINUS_EQUAL) \
TOKEN_TYPE(ARROW) \
TOKEN_TYPE(NOT) \
TOKEN_TYPE(NOT_EQUAL) \
TOKEN_TYPE(PERCENT) \
TOKEN_TYPE(PERCENT_EQUAL) \
TOKEN_TYPE(LESS) \
TOKEN_TYPE(LESS_EQUAL) \
TOKEN_TYPE(GREATER) \
TOKEN_TYPE(GREATER_EQUAL) \
TOKEN_TYPE(CARET) \
TOKEN_TYPE(CARET_CARET) \
TOKEN_TYPE(CARET_EQUAL) \
TOKEN_TYPE(PIPE) \
TOKEN_TYPE(PIPE_PIPE) \
TOKEN_TYPE(PIPE_EQUAL) \
TOKEN_TYPE(COLON) \
TOKEN_TYPE(COLON_COLON) \
TOKEN_TYPE(EQUAL) \
TOKEN_TYPE(EQUAL_EQUAL) \
TOKEN_TYPE(HASH) \
TOKEN_TYPE(HASH_HASH) \
TOKEN_TYPE(SLASH) \
TOKEN_TYPE(SLASH_EQUAL) \
TOKEN_TYPE(COMMENT) \
TOKEN_TYPE(STRING_LITERAL) \
TOKEN_TYPE(CHAR_CONSTANT) \
TOKEN_TYPE(NUMBER) \
TOKEN_TYPE(IDENTIFIER) \
TOKEN_TYPE(SPACING) \
TOKEN_TYPE(END_OF_LINE) \
TOKEN_TYPE(END_OF_STREAM)

// TODO(yuval): Maybe add an "export" keyword

#define KEYWORD_TOKEN_TYPES \
KEYWORD_TOKEN_TYPE(BOOL_CONSTANT, "true") \
KEYWORD_TOKEN_TYPE(CONST, "const") \
KEYWORD_TOKEN_TYPE(VOLATILE, "volatile") \
KEYWORD_TOKEN_TYPE(IF, "if") \
KEYWORD_TOKEN_TYPE(SWITCH, "switch") \
KEYWORD_TOKEN_TYPE(FOR, "for") \
KEYWORD_TOKEN_TYPE(WHILE, "while") \
KEYWORD_TOKEN_TYPE(DO, "do") \
KEYWORD_TOKEN_TYPE(ELSE, "else") \
KEYWORD_TOKEN_TYPE(CASE, "case") \
KEYWORD_TOKEN_TYPE(DEFAULT, "default") \
KEYWORD_TOKEN_TYPE(BREAK, "break") \
KEYWORD_TOKEN_TYPE(CONTINUE, "continue") \
KEYWORD_TOKEN_TYPE(RETURN, "return") \
KEYWORD_TOKEN_TYPE(GOTO, "goto") \
KEYWORD_TOKEN_TYPE(STRUCT, "struct") \
KEYWORD_TOKEN_TYPE(ENUM, "enum") \
KEYWORD_TOKEN_TYPE(UNION, "union") \
KEYWORD_TOKEN_TYPE(TYPEDEF, "typedef") \
KEYWORD_TOKEN_TYPE(STATIC, "static") \
KEYWORD_TOKEN_TYPE(INLINE, "inline") \
KEYWORD_TOKEN_TYPE(EXTERN, "extern") \

#define PP_KEYWORD_TOKEN_TYPES \
PP_KEYWORD_TOKEN_TYPE(PP_INCLUDE, "include") \
PP_KEYWORD_TOKEN_TYPE(PP_DEFINE, "define") \
PP_KEYWORD_TOKEN_TYPE(PP_IF, "if") \
PP_KEYWORD_TOKEN_TYPE(PP_ELIF, "elif") \
PP_KEYWORD_TOKEN_TYPE(PP_ELSE, "else") \
PP_KEYWORD_TOKEN_TYPE(PP_IFDEF, "ifdef") \
PP_KEYWORD_TOKEN_TYPE(PP_IFNDEF, "ifndef") \
PP_KEYWORD_TOKEN_TYPE(PP_ENDIF, "endif") \
PP_KEYWORD_TOKEN_TYPE(PP_IMPORT, "import") \
PP_KEYWORD_TOKEN_TYPE(PP_PRAGMA, "pragma") \
PP_KEYWORD_TOKEN_TYPE(PP_UNDEF, "undef") \
PP_KEYWORD_TOKEN_TYPE(PP_ERROR, "error") \
PP_KEYWORD_TOKEN_TYPE(PP_USING, "using")

#define PP_KEYWORD_TOKEN_TYPES_UPPER \
PP_KEYWORD_TOKEN_TYPE(PP_INCLUDE, "INCLUDE") \
PP_KEYWORD_TOKEN_TYPE(PP_DEFINE, "DEFINE") \
PP_KEYWORD_TOKEN_TYPE(PP_IF, "IF") \
PP_KEYWORD_TOKEN_TYPE(PP_ELIF, "ELIF") \
PP_KEYWORD_TOKEN_TYPE(PP_ELSE, "ELSE") \
PP_KEYWORD_TOKEN_TYPE(PP_IFDEF, "IFDEF") \
PP_KEYWORD_TOKEN_TYPE(PP_IFNDEF, "IFNDEF") \
PP_KEYWORD_TOKEN_TYPE(PP_ENDIF, "ENDIF") \
PP_KEYWORD_TOKEN_TYPE(PP_IMPORT, "IMPORT") \
PP_KEYWORD_TOKEN_TYPE(PP_PRAGMA, "PRAGMA") \
PP_KEYWORD_TOKEN_TYPE(PP_UNDEF, "UNDEF") \
PP_KEYWORD_TOKEN_TYPE(PP_ERROR, "ERROR") \
PP_KEYWORD_TOKEN_TYPE(PP_USING, "USING")

enum Token_Type
{
#define TOKEN_TYPE(type) JOIN2(TOKEN_, type),
    TOKEN_TYPES
#undef TOKEN_TYPE
    
#define KEYWORD_TOKEN_TYPE(type, ...) JOIN2(TOKEN_, type),
        KEYWORD_TOKEN_TYPES
#undef KEYWORD_TOKEN_TYPE
    
#define PP_KEYWORD_TOKEN_TYPE(type, ...) JOIN2(TOKEN_, type),
        PP_KEYWORD_TOKEN_TYPES
#undef PP_KEYWORD_TOKEN_TYPE
};

struct Token {
    Code_File file;
    
    s32 line_number;
    s32 column_number;
    
    Token_Type type;
    String text;
    String file_data;
    
    s32 value_s32;
    f32 value_f32;
};

struct Lexer {
    Code_File file;
    
    s32 line_number;
    s32 column_number;
    
    String input;
    char at[2];
    
    b32 error;
};

// TODO(yuval): Maybe add a better data structure for faster lookup
struct Token_Name_And_Type {
    const char* name;
    Token_Type type;
};

#define BUILD_LEXER_H
#endif // #if !defined(BUILD_LEXER_H)